<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Aliquot Sequence Research: pomyang_kparent/src/moewsmoews_sieve.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Aliquot Sequence Research
   &#160;<span id="projectnumber">2.0</span>
   </div>
   <div id="projectbrief">Compute properties of the sum-of-proper-divisors function.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_9f4a420dda9f9457760cfca95ea7641c.html">pomyang_kparent</a></li><li class="navelem"><a class="el" href="dir_05bd5b20feac2949e2e37b7079d1a622.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">moewsmoews_sieve.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Functions to sieve blocks of sigma function.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad072e5474e4673d2b63ae77978a6f354"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsieve__config__t.html">sieve_config_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="moewsmoews__sieve_8c.html#ad072e5474e4673d2b63ae77978a6f354">moews_init_sieve</a> (size_t bound, size_t seg_len)</td></tr>
<tr class="memdesc:ad072e5474e4673d2b63ae77978a6f354"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a <a class="el" href="structsieve__config__t.html" title="configuration and computed values needed to operate sieve, only 1 needed for multiple threads">sieve_config_t</a> which is shared by a pool of workers  <a href="moewsmoews__sieve_8c.html#ad072e5474e4673d2b63ae77978a6f354">More...</a><br /></td></tr>
<tr class="separator:ad072e5474e4673d2b63ae77978a6f354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51febebc5355cfca31c58108a6ec5f2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="moewsmoews__sieve_8c.html#a51febebc5355cfca31c58108a6ec5f2c">moews_destroy_sieve</a> (<a class="el" href="structsieve__config__t.html">sieve_config_t</a> *cfg)</td></tr>
<tr class="memdesc:a51febebc5355cfca31c58108a6ec5f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">free's memory associated with <a class="el" href="structsieve__config__t.html" title="configuration and computed values needed to operate sieve, only 1 needed for multiple threads">sieve_config_t</a>  <a href="moewsmoews__sieve_8c.html#a51febebc5355cfca31c58108a6ec5f2c">More...</a><br /></td></tr>
<tr class="separator:a51febebc5355cfca31c58108a6ec5f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33ee37f9625b5e2abe481351eb783b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsieve__worker__t.html">sieve_worker_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="moewsmoews__sieve_8c.html#ab33ee37f9625b5e2abe481351eb783b7">moews_init_worker</a> (const <a class="el" href="structsieve__config__t.html">sieve_config_t</a> *cfg)</td></tr>
<tr class="memdesc:ab33ee37f9625b5e2abe481351eb783b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a worker object which can be used to run the sieve  <a href="moewsmoews__sieve_8c.html#ab33ee37f9625b5e2abe481351eb783b7">More...</a><br /></td></tr>
<tr class="separator:ab33ee37f9625b5e2abe481351eb783b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17383cd28d0924852a1a52f99caa91e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="moewsmoews__sieve_8c.html#a17383cd28d0924852a1a52f99caa91e0">destroy_worker</a> (<a class="el" href="structsieve__worker__t.html">sieve_worker_t</a> *worker)</td></tr>
<tr class="memdesc:a17383cd28d0924852a1a52f99caa91e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">free's memory associated with <a class="el" href="structsieve__worker__t.html" title="worker which holds state about a single thread running the sieve">sieve_worker_t</a>  <a href="moewsmoews__sieve_8c.html#a17383cd28d0924852a1a52f99caa91e0">More...</a><br /></td></tr>
<tr class="separator:a17383cd28d0924852a1a52f99caa91e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1001f46d63af8f3f4ccebdb559a07d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="moewsmoews__sieve_8c.html#ac1001f46d63af8f3f4ccebdb559a07d5">moews_sieve_odd_standard</a> (<a class="el" href="structsieve__worker__t.html">sieve_worker_t</a> *worker, const uint64_t seg_start)</td></tr>
<tr class="memdesc:ac1001f46d63af8f3f4ccebdb559a07d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">runs sieve for odd sigma(m)  <a href="moewsmoews__sieve_8c.html#ac1001f46d63af8f3f4ccebdb559a07d5">More...</a><br /></td></tr>
<tr class="separator:ac1001f46d63af8f3f4ccebdb559a07d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a500516c408fdc767e6621cc7273f6d2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="moewsmoews__sieve_8c.html#a500516c408fdc767e6621cc7273f6d2e">moews_sieve_odd_squared</a> (<a class="el" href="structsieve__worker__t.html">sieve_worker_t</a> *worker, const uint64_t seg_start)</td></tr>
<tr class="memdesc:a500516c408fdc767e6621cc7273f6d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">takes odd m in range and runs sieve for sigma(m * m)  <a href="moewsmoews__sieve_8c.html#a500516c408fdc767e6621cc7273f6d2e">More...</a><br /></td></tr>
<tr class="separator:a500516c408fdc767e6621cc7273f6d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae30ddb5a343bf6b7e376c290989bb4c7"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="moewsmoews__sieve_8c.html#ae30ddb5a343bf6b7e376c290989bb4c7">moews_lookup_sigma_m</a> (const <a class="el" href="structsieve__worker__t.html">sieve_worker_t</a> *worker, uint64_t m)</td></tr>
<tr class="memdesc:ae30ddb5a343bf6b7e376c290989bb4c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">lookup sigma(m) from m in a sieved block  <a href="moewsmoews__sieve_8c.html#ae30ddb5a343bf6b7e376c290989bb4c7">More...</a><br /></td></tr>
<tr class="separator:ae30ddb5a343bf6b7e376c290989bb4c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e5d02e44e8f82167a96e2a774319618"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="moewsmoews__sieve_8c.html#a8e5d02e44e8f82167a96e2a774319618">moews_lookup_sigma_m_squared</a> (const <a class="el" href="structsieve__worker__t.html">sieve_worker_t</a> *worker, uint64_t m)</td></tr>
<tr class="memdesc:a8e5d02e44e8f82167a96e2a774319618"><td class="mdescLeft">&#160;</td><td class="mdescRight">lookup sigma(m * m) from m in a sieved block  <a href="moewsmoews__sieve_8c.html#a8e5d02e44e8f82167a96e2a774319618">More...</a><br /></td></tr>
<tr class="separator:a8e5d02e44e8f82167a96e2a774319618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afed04de36ee0b30feb9f07ad8a43681d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="moewsmoews__sieve_8c.html#afed04de36ee0b30feb9f07ad8a43681d">moews_check_prime</a> (const <a class="el" href="structsieve__worker__t.html">sieve_worker_t</a> *worker, uint64_t m)</td></tr>
<tr class="memdesc:afed04de36ee0b30feb9f07ad8a43681d"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if odd numbers in range (seg_start, seg_start + seg_len) is prime  <a href="moewsmoews__sieve_8c.html#afed04de36ee0b30feb9f07ad8a43681d">More...</a><br /></td></tr>
<tr class="separator:afed04de36ee0b30feb9f07ad8a43681d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a449d452078f78dc23ab2169df323375e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="moewsmoews__sieve_8c.html#a449d452078f78dc23ab2169df323375e">moews_estimate_heap_usage</a> (size_t bound, size_t seg_len, size_t num_workers)</td></tr>
<tr class="memdesc:a449d452078f78dc23ab2169df323375e"><td class="mdescLeft">&#160;</td><td class="mdescRight">estimates how much heap the sieving buffers will require  <a href="moewsmoews__sieve_8c.html#a449d452078f78dc23ab2169df323375e">More...</a><br /></td></tr>
<tr class="separator:a449d452078f78dc23ab2169df323375e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Functions to sieve blocks of sigma function. </p>
<dl class="section author"><dt>Author</dt><dd>Anton Mosunov and Gavin Guinn (<a href="#" onclick="location.href='mai'+'lto:'+'gav'+'in'+'gui'+'nn'+'1@g'+'ma'+'il.'+'co'+'m'; return false;">gavin<span style="display: none;">.nosp@m.</span>guin<span style="display: none;">.nosp@m.</span>n1@gm<span style="display: none;">.nosp@m.</span>ail.<span style="display: none;">.nosp@m.</span>com</a>) </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Originally Apr 18, 2014, modified 2021-12-27</dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>Public Domain (Please credit me; if you find this code useful I would love to hear about your work!)</dd></dl>
<h2><a class="anchor" id="autotoc_md21"></a>
PERFORMANCE SUMMARY</h2>
<p>The parameter seg_len has will increase sieve runtime by upto a order-of-magnitude if set to low/high. If seg_len is set to low the sieve will execute far more instructions than needed to complete the same outcome, as it's performance is improves with larger values of seg_len. I believe^ the amount of instructions increases exponentially as seg_len shrinks, judging by the cachegrind instruction lookup counts. However if seg_len is set to high the sieve will start thrashing at the cache missing reads/writes in the intermediate sieving steps thus degrading performance. I believe^^ this effect is more pronounced at bounds lower than ~10^9 as seg_len's that result in a reasonable amount of operations also happen to require sieving buffers that fit (very approximately) into my 32mb LL cache.</p>
<h2><a class="anchor" id="autotoc_md22"></a>
TODO</h2>
<p>test ^ and ^^</p>
<h2><a class="anchor" id="autotoc_md23"></a>
PERFORMANCE</h2>
<p>The performance of this sieve is highly variable on the value of seg_len, unfortunately not in a clearly tractable way. It is clear that if seg_len is set to low (whatever that means) the sieve will do a lot of additional operations for the same result. This selected cachegrind/time output from 2 pom_yang run is illustrative:</p>
<div class="fragment"><div class="line">./cli --bound=100000000 --seg_len=400000 --num_locks=1000000 --preimage_count_bits=1 --num_thread=12</div>
<div class="line"> ==*== I   refs:      19,091,262,194</div>
<div class="line"> ==*==</div>
<div class="line"> ==*== D   refs:       26,107,875,360  (25,263,200,724 rd   + 844,674,636 wr)</div>
<div class="line"> ==*== D1  misses:        268,703,487  (   255,239,558 rd   +  13,463,929 wr)</div>
<div class="line"> ==*== LLd misses:            406,127  (       274,082 rd   +     132,045 wr)</div>
<div class="line"> ==*== D1  miss rate:             1.0% (           1.0%     +         1.6%  )</div>
<div class="line">6.28s user 0.07s system 901% cpu 0.704 total</div>
<div class="line"> </div>
<div class="line">./cli --bound=100000000 --seg_len=12500 --num_locks=1000000 --preimage_count_bits=1 --num_thread=12</div>
<div class="line"> ==*== I   refs:      190,995,976,640</div>
<div class="line"> ==*==</div>
<div class="line"> ==*== D   refs:       4,448,783,095  (3,658,655,908 rd   + 790,127,187 wr)</div>
<div class="line"> ==*== D1  misses:       304,675,262  (  291,274,461 rd   +  13,400,801 wr)</div>
<div class="line"> ==*== LLd misses:         8,850,772  (    5,407,998 rd   +   3,442,774 wr)</div>
<div class="line"> ==*== D1  miss rate:            6.8% (          8.0%     +         1.7%  )</div>
<div class="line">28.27s user 0.04s system 1052% cpu 2.689 total</div>
</div><!-- fragment --><p>Note that the seg_len=12500 is running an order of magnitude more instructions and far fewer references on the data cache, these references are relatively inaccurate.</p>
<p>The seg_len value can also degrade performace if it is set to high:</p>
<div class="fragment"><div class="line">./cli --bound=100000000 --seg_len=4000000 --num_locks=$((10**6)) --preimage_count_bits=1 --num_thread=12</div>
<div class="line"> ==*== I   refs:      13,701,814,468</div>
<div class="line"> ==*==</div>
<div class="line"> ==*== D   refs:       3,755,366,091  (2,955,265,779 rd   + 800,100,312 wr)</div>
<div class="line"> ==*== D1  misses:       312,794,587  (  298,947,273 rd   +  13,847,314 wr)</div>
<div class="line"> ==*== LLd misses:         6,388,217  (    2,678,555 rd   +   3,709,662 wr)</div>
<div class="line"> ==*== D1  miss rate:            8.3% (         10.1%     +         1.7%  )</div>
<div class="line">12.94s user 0.36s system 744% cpu 1.786 total</div>
</div><!-- fragment --><p>Comparing to the seg_len=400000 run we can observe that slightly less instructions are being executed but we are still in the same order of magnitude. More interestingly we can notice this run made an order of magnitude fewer references to the data cache and.. those references were much less accurate, likely accounting for the performace degradation. The vast majority of these misses originate from interactions with the sigma and numbers buffers.</p>
<h2><a class="anchor" id="autotoc_md24"></a>
SEE</h2>
<p>Files in the cg directory for more details.</p>
<h2><a class="anchor" id="autotoc_md25"></a>
ALGORITHM</h2>
<p>This is a rewrite of Anton Mosunov's implementation of the [Moews and Moews] sieving algorithm, prepared to utilized in the tabulation of non-aliquots, sect. 3 of [Chum et al.]. This implementation includes undocumented optimization on the original method of [Moews and Moews] that are essential for performance, I can't make any sense of why it works however. The _meows_naive_sieve implements the algorithm as described in the paper, it is much slower.</p>
<h2><a class="anchor" id="autotoc_md26"></a>
CITATIONS</h2>
<p>-&gt; [Moews and Moews] Moews, D. and Moews, P. C. (1991). A search for aliquot cycles below 10 10. Mathematics of Computation, 57(196):849.</p>
<p>-&gt; [Chum et al.] Chum, K., Guy, R. K., Jacobson, J. M. J., and Mosunov, A. S. (2018). Numerical and statistical analysis of aliquot sequences. Experimental Mathematics, 29(4):414–425. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a17383cd28d0924852a1a52f99caa91e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17383cd28d0924852a1a52f99caa91e0">&#9670;&nbsp;</a></span>destroy_worker()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void destroy_worker </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsieve__worker__t.html">sieve_worker_t</a> *&#160;</td>
          <td class="paramname"><em>worker</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>free's memory associated with <a class="el" href="structsieve__worker__t.html" title="worker which holds state about a single thread running the sieve">sieve_worker_t</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">worker</td><td>to be free'd </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afed04de36ee0b30feb9f07ad8a43681d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afed04de36ee0b30feb9f07ad8a43681d">&#9670;&nbsp;</a></span>moews_check_prime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool moews_check_prime </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsieve__worker__t.html">sieve_worker_t</a> *&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>checks if odd numbers in range (seg_start, seg_start + seg_len) is prime </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">worker</td><td>that has previously run moews_sieve_odd_standard </td></tr>
    <tr><td class="paramname">m</td><td>check if this odd number in range (seg_start, seg_start + seg_len) is prime </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool is prime </dd></dl>

</div>
</div>
<a id="a51febebc5355cfca31c58108a6ec5f2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51febebc5355cfca31c58108a6ec5f2c">&#9670;&nbsp;</a></span>moews_destroy_sieve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void moews_destroy_sieve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsieve__config__t.html">sieve_config_t</a> *&#160;</td>
          <td class="paramname"><em>cfg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>free's memory associated with <a class="el" href="structsieve__config__t.html" title="configuration and computed values needed to operate sieve, only 1 needed for multiple threads">sieve_config_t</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cfg</td><td>to be free'd </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a449d452078f78dc23ab2169df323375e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a449d452078f78dc23ab2169df323375e">&#9670;&nbsp;</a></span>moews_estimate_heap_usage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t moews_estimate_heap_usage </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seg_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_workers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>estimates how much heap the sieving buffers will require </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bound</td><td>sieve all odd sigma upto to bound </td></tr>
    <tr><td class="paramname">seg_len</td><td>size of range to sieve in a step </td></tr>
    <tr><td class="paramname">num_workers</td><td>number of threads working </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t approx bytes to be consumed </dd></dl>

</div>
</div>
<a id="ad072e5474e4673d2b63ae77978a6f354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad072e5474e4673d2b63ae77978a6f354">&#9670;&nbsp;</a></span>moews_init_sieve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsieve__config__t.html">sieve_config_t</a>* moews_init_sieve </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seg_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a <a class="el" href="structsieve__config__t.html" title="configuration and computed values needed to operate sieve, only 1 needed for multiple threads">sieve_config_t</a> which is shared by a pool of workers </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bound</td><td>sieving all odd sigma upto to bound </td></tr>
    <tr><td class="paramname">seg_len</td><td>size of range to sieve in a step </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sieve_config_t* config struct which is free'd by calling moews_destroy_sieve </dd></dl>

</div>
</div>
<a id="ab33ee37f9625b5e2abe481351eb783b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab33ee37f9625b5e2abe481351eb783b7">&#9670;&nbsp;</a></span>moews_init_worker()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsieve__worker__t.html">sieve_worker_t</a>* moews_init_worker </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsieve__config__t.html">sieve_config_t</a> *&#160;</td>
          <td class="paramname"><em>cfg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a worker object which can be used to run the sieve </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cfg</td><td>initalized sieve configuration struct </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sieve_worker_t* </dd></dl>

</div>
</div>
<a id="ae30ddb5a343bf6b7e376c290989bb4c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae30ddb5a343bf6b7e376c290989bb4c7">&#9670;&nbsp;</a></span>moews_lookup_sigma_m()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t moews_lookup_sigma_m </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsieve__worker__t.html">sieve_worker_t</a> *&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>lookup sigma(m) from m in a sieved block </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">worker</td><td>see definition, has run moews_sieve_odd_standard last </td></tr>
    <tr><td class="paramname">m</td><td>number to lookup </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint64_t sigma(m) </dd></dl>

</div>
</div>
<a id="a8e5d02e44e8f82167a96e2a774319618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e5d02e44e8f82167a96e2a774319618">&#9670;&nbsp;</a></span>moews_lookup_sigma_m_squared()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t moews_lookup_sigma_m_squared </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsieve__worker__t.html">sieve_worker_t</a> *&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>lookup sigma(m * m) from m in a sieved block </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">worker</td><td>see definition, has run moews_sieve_odd_squared last </td></tr>
    <tr><td class="paramname">m</td><td>number to lookup </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint64_t sigma(m * m) </dd></dl>

</div>
</div>
<a id="a500516c408fdc767e6621cc7273f6d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a500516c408fdc767e6621cc7273f6d2e">&#9670;&nbsp;</a></span>moews_sieve_odd_squared()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void moews_sieve_odd_squared </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsieve__worker__t.html">sieve_worker_t</a> *&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>seg_start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>takes odd m in range and runs sieve for sigma(m * m) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">worker</td><td>see struct definiton </td></tr>
    <tr><td class="paramname">seg_start</td><td>start of range to sieve </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1001f46d63af8f3f4ccebdb559a07d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1001f46d63af8f3f4ccebdb559a07d5">&#9670;&nbsp;</a></span>moews_sieve_odd_standard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void moews_sieve_odd_standard </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsieve__worker__t.html">sieve_worker_t</a> *&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>seg_start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>runs sieve for odd sigma(m) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">worker</td><td>see struct definiton </td></tr>
    <tr><td class="paramname">seg_start</td><td>start of range to sieve </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
