\hypertarget{moewsmoews__sieve_8c}{}\doxysubsection{pomyang\+\_\+kparent/src/moewsmoews\+\_\+sieve.c File Reference}
\label{moewsmoews__sieve_8c}\index{pomyang\_kparent/src/moewsmoews\_sieve.c@{pomyang\_kparent/src/moewsmoews\_sieve.c}}


Functions to sieve blocks of sigma function.  


\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{structsieve__config__t}{sieve\+\_\+config\+\_\+t}} $\ast$ \mbox{\hyperlink{moewsmoews__sieve_8c_ad072e5474e4673d2b63ae77978a6f354}{moews\+\_\+init\+\_\+sieve}} (size\+\_\+t bound, size\+\_\+t seg\+\_\+len)
\begin{DoxyCompactList}\small\item\em creates a \mbox{\hyperlink{structsieve__config__t}{sieve\+\_\+config\+\_\+t}} which is shared by a pool of workers \end{DoxyCompactList}\item 
void \mbox{\hyperlink{moewsmoews__sieve_8c_a51febebc5355cfca31c58108a6ec5f2c}{moews\+\_\+destroy\+\_\+sieve}} (\mbox{\hyperlink{structsieve__config__t}{sieve\+\_\+config\+\_\+t}} $\ast$cfg)
\begin{DoxyCompactList}\small\item\em free\textquotesingle{}s memory associated with \mbox{\hyperlink{structsieve__config__t}{sieve\+\_\+config\+\_\+t}} \end{DoxyCompactList}\item 
\mbox{\hyperlink{structsieve__worker__t}{sieve\+\_\+worker\+\_\+t}} $\ast$ \mbox{\hyperlink{moewsmoews__sieve_8c_ab33ee37f9625b5e2abe481351eb783b7}{moews\+\_\+init\+\_\+worker}} (const \mbox{\hyperlink{structsieve__config__t}{sieve\+\_\+config\+\_\+t}} $\ast$cfg)
\begin{DoxyCompactList}\small\item\em creates a worker object which can be used to run the sieve \end{DoxyCompactList}\item 
void \mbox{\hyperlink{moewsmoews__sieve_8c_a17383cd28d0924852a1a52f99caa91e0}{destroy\+\_\+worker}} (\mbox{\hyperlink{structsieve__worker__t}{sieve\+\_\+worker\+\_\+t}} $\ast$worker)
\begin{DoxyCompactList}\small\item\em free\textquotesingle{}s memory associated with \mbox{\hyperlink{structsieve__worker__t}{sieve\+\_\+worker\+\_\+t}} \end{DoxyCompactList}\item 
void \mbox{\hyperlink{moewsmoews__sieve_8c_ac1001f46d63af8f3f4ccebdb559a07d5}{moews\+\_\+sieve\+\_\+odd\+\_\+standard}} (\mbox{\hyperlink{structsieve__worker__t}{sieve\+\_\+worker\+\_\+t}} $\ast$worker, const uint64\+\_\+t seg\+\_\+start)
\begin{DoxyCompactList}\small\item\em runs sieve for odd sigma(m) \end{DoxyCompactList}\item 
void \mbox{\hyperlink{moewsmoews__sieve_8c_a500516c408fdc767e6621cc7273f6d2e}{moews\+\_\+sieve\+\_\+odd\+\_\+squared}} (\mbox{\hyperlink{structsieve__worker__t}{sieve\+\_\+worker\+\_\+t}} $\ast$worker, const uint64\+\_\+t seg\+\_\+start)
\begin{DoxyCompactList}\small\item\em takes odd m in range and runs sieve for sigma(m $\ast$ m) \end{DoxyCompactList}\item 
uint64\+\_\+t \mbox{\hyperlink{moewsmoews__sieve_8c_ae30ddb5a343bf6b7e376c290989bb4c7}{moews\+\_\+lookup\+\_\+sigma\+\_\+m}} (const \mbox{\hyperlink{structsieve__worker__t}{sieve\+\_\+worker\+\_\+t}} $\ast$worker, uint64\+\_\+t m)
\begin{DoxyCompactList}\small\item\em lookup sigma(m) from m in a sieved block \end{DoxyCompactList}\item 
uint64\+\_\+t \mbox{\hyperlink{moewsmoews__sieve_8c_a8e5d02e44e8f82167a96e2a774319618}{moews\+\_\+lookup\+\_\+sigma\+\_\+m\+\_\+squared}} (const \mbox{\hyperlink{structsieve__worker__t}{sieve\+\_\+worker\+\_\+t}} $\ast$worker, uint64\+\_\+t m)
\begin{DoxyCompactList}\small\item\em lookup sigma(m $\ast$ m) from m in a sieved block \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{moewsmoews__sieve_8c_afed04de36ee0b30feb9f07ad8a43681d}{moews\+\_\+check\+\_\+prime}} (const \mbox{\hyperlink{structsieve__worker__t}{sieve\+\_\+worker\+\_\+t}} $\ast$worker, uint64\+\_\+t m)
\begin{DoxyCompactList}\small\item\em checks if odd numbers in range (seg\+\_\+start, seg\+\_\+start + seg\+\_\+len) is prime \end{DoxyCompactList}\item 
size\+\_\+t \mbox{\hyperlink{moewsmoews__sieve_8c_a449d452078f78dc23ab2169df323375e}{moews\+\_\+estimate\+\_\+heap\+\_\+usage}} (size\+\_\+t bound, size\+\_\+t seg\+\_\+len, size\+\_\+t num\+\_\+workers)
\begin{DoxyCompactList}\small\item\em estimates how much heap the sieving buffers will require \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsubsection{Detailed Description}
Functions to sieve blocks of sigma function. 

\begin{DoxyAuthor}{Author}
Anton Mosunov and Gavin Guinn (\href{mailto:gavinguinn1@gmail.com}{\texttt{ gavinguinn1@gmail.\+com}}) 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
Originally Apr 18, 2014, modified 2021-\/12-\/27
\end{DoxyDate}
\begin{DoxyCopyright}{Copyright}
Public Domain (Please credit me; if you find this code useful I would love to hear about your work!)
\end{DoxyCopyright}
\hypertarget{moewsmoews__sieve_8c_autotoc_md2}{}\doxyparagraph{P\+E\+R\+F\+O\+R\+M\+A\+N\+C\+E S\+U\+M\+M\+A\+RY}\label{moewsmoews__sieve_8c_autotoc_md2}
The parameter seg\+\_\+len has will increase sieve runtime by upto a order-\/of-\/magnitude if set to low/high. If seg\+\_\+len is set to low the sieve will execute far more instructions than needed to complete the same outcome, as it\textquotesingle{}s performance is improves with larger values of seg\+\_\+len. I believe$^\wedge$ the amount of instructions increases exponentially as seg\+\_\+len shrinks, judging by the cachegrind instruction lookup counts. However if seg\+\_\+len is set to high the sieve will start thrashing at the cache missing reads/writes in the intermediate sieving steps thus degrading performance. I believe$^\wedge$$^\wedge$ this effect is more pronounced at bounds lower than $\sim$10$^\wedge$9 as seg\+\_\+len\textquotesingle{}s that result in a reasonable amount of operations also happen to require sieving buffers that fit (very approximately) into my 32mb LL cache.\hypertarget{moewsmoews__sieve_8c_autotoc_md3}{}\doxyparagraph{T\+O\+DO}\label{moewsmoews__sieve_8c_autotoc_md3}
test $^\wedge$ and $^\wedge$$^\wedge$\hypertarget{moewsmoews__sieve_8c_autotoc_md4}{}\doxyparagraph{P\+E\+R\+F\+O\+R\+M\+A\+N\+CE}\label{moewsmoews__sieve_8c_autotoc_md4}
The performance of this sieve is highly variable on the value of seg\+\_\+len, unfortunately not in a clearly tractable way. It is clear that if seg\+\_\+len is set to low (whatever that means) the sieve will do a lot of additional operations for the same result. This selected cachegrind/time output from 2 pom\+\_\+yang run is illustrative\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{./cli -\/-\/bound=100000000 -\/-\/seg\_len=400000 -\/-\/num\_locks=1000000 -\/-\/preimage\_count\_bits=1 -\/-\/num\_thread=12}
\DoxyCodeLine{ ==*== I   refs:      19,091,262,194}
\DoxyCodeLine{ ==*==}
\DoxyCodeLine{ ==*== D   refs:       26,107,875,360  (25,263,200,724 rd   + 844,674,636 wr)}
\DoxyCodeLine{ ==*== D1  misses:        268,703,487  (   255,239,558 rd   +  13,463,929 wr)}
\DoxyCodeLine{ ==*== LLd misses:            406,127  (       274,082 rd   +     132,045 wr)}
\DoxyCodeLine{ ==*== D1  miss rate:             1.0\% (           1.0\%     +         1.6\%  )}
\DoxyCodeLine{6.28s user 0.07s system 901\% cpu 0.704 total}
\DoxyCodeLine{}
\DoxyCodeLine{./cli -\/-\/bound=100000000 -\/-\/seg\_len=12500 -\/-\/num\_locks=1000000 -\/-\/preimage\_count\_bits=1 -\/-\/num\_thread=12}
\DoxyCodeLine{ ==*== I   refs:      190,995,976,640}
\DoxyCodeLine{ ==*==}
\DoxyCodeLine{ ==*== D   refs:       4,448,783,095  (3,658,655,908 rd   + 790,127,187 wr)}
\DoxyCodeLine{ ==*== D1  misses:       304,675,262  (  291,274,461 rd   +  13,400,801 wr)}
\DoxyCodeLine{ ==*== LLd misses:         8,850,772  (    5,407,998 rd   +   3,442,774 wr)}
\DoxyCodeLine{ ==*== D1  miss rate:            6.8\% (          8.0\%     +         1.7\%  )}
\DoxyCodeLine{28.27s user 0.04s system 1052\% cpu 2.689 total}
\end{DoxyCode}


Note that the seg\+\_\+len=12500 is running an order of magnitude more instructions and far fewer references on the data cache, these references are relatively inaccurate.

The seg\+\_\+len value can also degrade performace if it is set to high\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{./cli -\/-\/bound=100000000 -\/-\/seg\_len=4000000 -\/-\/num\_locks=\$((10**6)) -\/-\/preimage\_count\_bits=1 -\/-\/num\_thread=12}
\DoxyCodeLine{ ==*== I   refs:      13,701,814,468}
\DoxyCodeLine{ ==*==}
\DoxyCodeLine{ ==*== D   refs:       3,755,366,091  (2,955,265,779 rd   + 800,100,312 wr)}
\DoxyCodeLine{ ==*== D1  misses:       312,794,587  (  298,947,273 rd   +  13,847,314 wr)}
\DoxyCodeLine{ ==*== LLd misses:         6,388,217  (    2,678,555 rd   +   3,709,662 wr)}
\DoxyCodeLine{ ==*== D1  miss rate:            8.3\% (         10.1\%     +         1.7\%  )}
\DoxyCodeLine{12.94s user 0.36s system 744\% cpu 1.786 total}
\end{DoxyCode}


Comparing to the seg\+\_\+len=400000 run we can observe that slightly less instructions are being executed but we are still in the same order of magnitude. More interestingly we can notice this run made an order of magnitude fewer references to the data cache and.. those references were much less accurate, likely accounting for the performace degradation. The vast majority of these misses originate from interactions with the sigma and numbers buffers.\hypertarget{moewsmoews__sieve_8c_autotoc_md5}{}\doxyparagraph{S\+EE}\label{moewsmoews__sieve_8c_autotoc_md5}
Files in the cg directory for more details.\hypertarget{moewsmoews__sieve_8c_autotoc_md6}{}\doxyparagraph{A\+L\+G\+O\+R\+I\+T\+HM}\label{moewsmoews__sieve_8c_autotoc_md6}
This is a rewrite of Anton Mosunov\textquotesingle{}s implementation of the \mbox{[}Moews and Moews\mbox{]} sieving algorithm, prepared to utilized in the tabulation of non-\/aliquots, sect. 3 of \mbox{[}Chum et al.\mbox{]}. This implementation includes undocumented optimization on the original method of \mbox{[}Moews and Moews\mbox{]} that are essential for performance, I can\textquotesingle{}t make any sense of why it works however. The \+\_\+meows\+\_\+naive\+\_\+sieve implements the algorithm as described in the paper, it is much slower.\hypertarget{moewsmoews__sieve_8c_autotoc_md7}{}\doxyparagraph{C\+I\+T\+A\+T\+I\+O\+NS}\label{moewsmoews__sieve_8c_autotoc_md7}
-\/$>$ \mbox{[}Moews and Moews\mbox{]} Moews, D. and Moews, P. C. (1991). A search for aliquot cycles below 10 10. Mathematics of Computation, 57(196)\+:849.

-\/$>$ \mbox{[}Chum et al.\mbox{]} Chum, K., Guy, R. K., Jacobson, J. M. J., and Mosunov, A. S. (2018). Numerical and statistical analysis of aliquot sequences. Experimental Mathematics, 29(4)\+:414–425. 

\doxysubsubsection{Function Documentation}
\mbox{\Hypertarget{moewsmoews__sieve_8c_a17383cd28d0924852a1a52f99caa91e0}\label{moewsmoews__sieve_8c_a17383cd28d0924852a1a52f99caa91e0}} 
\index{moewsmoews\_sieve.c@{moewsmoews\_sieve.c}!destroy\_worker@{destroy\_worker}}
\index{destroy\_worker@{destroy\_worker}!moewsmoews\_sieve.c@{moewsmoews\_sieve.c}}
\doxyparagraph{\texorpdfstring{destroy\_worker()}{destroy\_worker()}}
{\footnotesize\ttfamily void destroy\+\_\+worker (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structsieve__worker__t}{sieve\+\_\+worker\+\_\+t}} $\ast$}]{worker }\end{DoxyParamCaption})}



free\textquotesingle{}s memory associated with \mbox{\hyperlink{structsieve__worker__t}{sieve\+\_\+worker\+\_\+t}} 


\begin{DoxyParams}{Parameters}
{\em worker} & to be free\textquotesingle{}d \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{moewsmoews__sieve_8c_afed04de36ee0b30feb9f07ad8a43681d}\label{moewsmoews__sieve_8c_afed04de36ee0b30feb9f07ad8a43681d}} 
\index{moewsmoews\_sieve.c@{moewsmoews\_sieve.c}!moews\_check\_prime@{moews\_check\_prime}}
\index{moews\_check\_prime@{moews\_check\_prime}!moewsmoews\_sieve.c@{moewsmoews\_sieve.c}}
\doxyparagraph{\texorpdfstring{moews\_check\_prime()}{moews\_check\_prime()}}
{\footnotesize\ttfamily bool moews\+\_\+check\+\_\+prime (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structsieve__worker__t}{sieve\+\_\+worker\+\_\+t}} $\ast$}]{worker,  }\item[{uint64\+\_\+t}]{m }\end{DoxyParamCaption})}



checks if odd numbers in range (seg\+\_\+start, seg\+\_\+start + seg\+\_\+len) is prime 


\begin{DoxyParams}{Parameters}
{\em worker} & that has previously run moews\+\_\+sieve\+\_\+odd\+\_\+standard \\
\hline
{\em m} & check if this odd number in range (seg\+\_\+start, seg\+\_\+start + seg\+\_\+len) is prime \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
bool is prime 
\end{DoxyReturn}
\mbox{\Hypertarget{moewsmoews__sieve_8c_a51febebc5355cfca31c58108a6ec5f2c}\label{moewsmoews__sieve_8c_a51febebc5355cfca31c58108a6ec5f2c}} 
\index{moewsmoews\_sieve.c@{moewsmoews\_sieve.c}!moews\_destroy\_sieve@{moews\_destroy\_sieve}}
\index{moews\_destroy\_sieve@{moews\_destroy\_sieve}!moewsmoews\_sieve.c@{moewsmoews\_sieve.c}}
\doxyparagraph{\texorpdfstring{moews\_destroy\_sieve()}{moews\_destroy\_sieve()}}
{\footnotesize\ttfamily void moews\+\_\+destroy\+\_\+sieve (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structsieve__config__t}{sieve\+\_\+config\+\_\+t}} $\ast$}]{cfg }\end{DoxyParamCaption})}



free\textquotesingle{}s memory associated with \mbox{\hyperlink{structsieve__config__t}{sieve\+\_\+config\+\_\+t}} 


\begin{DoxyParams}{Parameters}
{\em cfg} & to be free\textquotesingle{}d \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{moewsmoews__sieve_8c_a449d452078f78dc23ab2169df323375e}\label{moewsmoews__sieve_8c_a449d452078f78dc23ab2169df323375e}} 
\index{moewsmoews\_sieve.c@{moewsmoews\_sieve.c}!moews\_estimate\_heap\_usage@{moews\_estimate\_heap\_usage}}
\index{moews\_estimate\_heap\_usage@{moews\_estimate\_heap\_usage}!moewsmoews\_sieve.c@{moewsmoews\_sieve.c}}
\doxyparagraph{\texorpdfstring{moews\_estimate\_heap\_usage()}{moews\_estimate\_heap\_usage()}}
{\footnotesize\ttfamily size\+\_\+t moews\+\_\+estimate\+\_\+heap\+\_\+usage (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{bound,  }\item[{size\+\_\+t}]{seg\+\_\+len,  }\item[{size\+\_\+t}]{num\+\_\+workers }\end{DoxyParamCaption})}



estimates how much heap the sieving buffers will require 


\begin{DoxyParams}{Parameters}
{\em bound} & sieve all odd sigma upto to bound \\
\hline
{\em seg\+\_\+len} & size of range to sieve in a step \\
\hline
{\em num\+\_\+workers} & number of threads working \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
size\+\_\+t approx bytes to be consumed 
\end{DoxyReturn}
\mbox{\Hypertarget{moewsmoews__sieve_8c_ad072e5474e4673d2b63ae77978a6f354}\label{moewsmoews__sieve_8c_ad072e5474e4673d2b63ae77978a6f354}} 
\index{moewsmoews\_sieve.c@{moewsmoews\_sieve.c}!moews\_init\_sieve@{moews\_init\_sieve}}
\index{moews\_init\_sieve@{moews\_init\_sieve}!moewsmoews\_sieve.c@{moewsmoews\_sieve.c}}
\doxyparagraph{\texorpdfstring{moews\_init\_sieve()}{moews\_init\_sieve()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structsieve__config__t}{sieve\+\_\+config\+\_\+t}}$\ast$ moews\+\_\+init\+\_\+sieve (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{bound,  }\item[{size\+\_\+t}]{seg\+\_\+len }\end{DoxyParamCaption})}



creates a \mbox{\hyperlink{structsieve__config__t}{sieve\+\_\+config\+\_\+t}} which is shared by a pool of workers 


\begin{DoxyParams}{Parameters}
{\em bound} & sieving all odd sigma upto to bound \\
\hline
{\em seg\+\_\+len} & size of range to sieve in a step \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
sieve\+\_\+config\+\_\+t$\ast$ config struct which is free\textquotesingle{}d by calling moews\+\_\+destroy\+\_\+sieve 
\end{DoxyReturn}
\mbox{\Hypertarget{moewsmoews__sieve_8c_ab33ee37f9625b5e2abe481351eb783b7}\label{moewsmoews__sieve_8c_ab33ee37f9625b5e2abe481351eb783b7}} 
\index{moewsmoews\_sieve.c@{moewsmoews\_sieve.c}!moews\_init\_worker@{moews\_init\_worker}}
\index{moews\_init\_worker@{moews\_init\_worker}!moewsmoews\_sieve.c@{moewsmoews\_sieve.c}}
\doxyparagraph{\texorpdfstring{moews\_init\_worker()}{moews\_init\_worker()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structsieve__worker__t}{sieve\+\_\+worker\+\_\+t}}$\ast$ moews\+\_\+init\+\_\+worker (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structsieve__config__t}{sieve\+\_\+config\+\_\+t}} $\ast$}]{cfg }\end{DoxyParamCaption})}



creates a worker object which can be used to run the sieve 


\begin{DoxyParams}{Parameters}
{\em cfg} & initalized sieve configuration struct \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
sieve\+\_\+worker\+\_\+t$\ast$ 
\end{DoxyReturn}
\mbox{\Hypertarget{moewsmoews__sieve_8c_ae30ddb5a343bf6b7e376c290989bb4c7}\label{moewsmoews__sieve_8c_ae30ddb5a343bf6b7e376c290989bb4c7}} 
\index{moewsmoews\_sieve.c@{moewsmoews\_sieve.c}!moews\_lookup\_sigma\_m@{moews\_lookup\_sigma\_m}}
\index{moews\_lookup\_sigma\_m@{moews\_lookup\_sigma\_m}!moewsmoews\_sieve.c@{moewsmoews\_sieve.c}}
\doxyparagraph{\texorpdfstring{moews\_lookup\_sigma\_m()}{moews\_lookup\_sigma\_m()}}
{\footnotesize\ttfamily uint64\+\_\+t moews\+\_\+lookup\+\_\+sigma\+\_\+m (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structsieve__worker__t}{sieve\+\_\+worker\+\_\+t}} $\ast$}]{worker,  }\item[{uint64\+\_\+t}]{m }\end{DoxyParamCaption})}



lookup sigma(m) from m in a sieved block 


\begin{DoxyParams}{Parameters}
{\em worker} & see definition, has run moews\+\_\+sieve\+\_\+odd\+\_\+standard last \\
\hline
{\em m} & number to lookup \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
uint64\+\_\+t sigma(m) 
\end{DoxyReturn}
\mbox{\Hypertarget{moewsmoews__sieve_8c_a8e5d02e44e8f82167a96e2a774319618}\label{moewsmoews__sieve_8c_a8e5d02e44e8f82167a96e2a774319618}} 
\index{moewsmoews\_sieve.c@{moewsmoews\_sieve.c}!moews\_lookup\_sigma\_m\_squared@{moews\_lookup\_sigma\_m\_squared}}
\index{moews\_lookup\_sigma\_m\_squared@{moews\_lookup\_sigma\_m\_squared}!moewsmoews\_sieve.c@{moewsmoews\_sieve.c}}
\doxyparagraph{\texorpdfstring{moews\_lookup\_sigma\_m\_squared()}{moews\_lookup\_sigma\_m\_squared()}}
{\footnotesize\ttfamily uint64\+\_\+t moews\+\_\+lookup\+\_\+sigma\+\_\+m\+\_\+squared (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structsieve__worker__t}{sieve\+\_\+worker\+\_\+t}} $\ast$}]{worker,  }\item[{uint64\+\_\+t}]{m }\end{DoxyParamCaption})}



lookup sigma(m $\ast$ m) from m in a sieved block 


\begin{DoxyParams}{Parameters}
{\em worker} & see definition, has run moews\+\_\+sieve\+\_\+odd\+\_\+squared last \\
\hline
{\em m} & number to lookup \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
uint64\+\_\+t sigma(m $\ast$ m) 
\end{DoxyReturn}
\mbox{\Hypertarget{moewsmoews__sieve_8c_a500516c408fdc767e6621cc7273f6d2e}\label{moewsmoews__sieve_8c_a500516c408fdc767e6621cc7273f6d2e}} 
\index{moewsmoews\_sieve.c@{moewsmoews\_sieve.c}!moews\_sieve\_odd\_squared@{moews\_sieve\_odd\_squared}}
\index{moews\_sieve\_odd\_squared@{moews\_sieve\_odd\_squared}!moewsmoews\_sieve.c@{moewsmoews\_sieve.c}}
\doxyparagraph{\texorpdfstring{moews\_sieve\_odd\_squared()}{moews\_sieve\_odd\_squared()}}
{\footnotesize\ttfamily void moews\+\_\+sieve\+\_\+odd\+\_\+squared (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structsieve__worker__t}{sieve\+\_\+worker\+\_\+t}} $\ast$}]{worker,  }\item[{uint64\+\_\+t}]{seg\+\_\+start }\end{DoxyParamCaption})}



takes odd m in range and runs sieve for sigma(m $\ast$ m) 


\begin{DoxyParams}{Parameters}
{\em worker} & see struct definiton \\
\hline
{\em seg\+\_\+start} & start of range to sieve \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{moewsmoews__sieve_8c_ac1001f46d63af8f3f4ccebdb559a07d5}\label{moewsmoews__sieve_8c_ac1001f46d63af8f3f4ccebdb559a07d5}} 
\index{moewsmoews\_sieve.c@{moewsmoews\_sieve.c}!moews\_sieve\_odd\_standard@{moews\_sieve\_odd\_standard}}
\index{moews\_sieve\_odd\_standard@{moews\_sieve\_odd\_standard}!moewsmoews\_sieve.c@{moewsmoews\_sieve.c}}
\doxyparagraph{\texorpdfstring{moews\_sieve\_odd\_standard()}{moews\_sieve\_odd\_standard()}}
{\footnotesize\ttfamily void moews\+\_\+sieve\+\_\+odd\+\_\+standard (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structsieve__worker__t}{sieve\+\_\+worker\+\_\+t}} $\ast$}]{worker,  }\item[{uint64\+\_\+t}]{seg\+\_\+start }\end{DoxyParamCaption})}



runs sieve for odd sigma(m) 


\begin{DoxyParams}{Parameters}
{\em worker} & see struct definiton \\
\hline
{\em seg\+\_\+start} & start of range to sieve \\
\hline
\end{DoxyParams}
